\documentclass[11pt, oneside]{article}  
\usepackage[margin=0.5in]{geometry} % Margins
\usepackage[ampersand]{easylist} % Bullets for lists
\usepackage[bottom]{footmisc}  % Glue footnotes to bottom
\usepackage{graphicx}
\graphicspath{ {imgs/} }

\title{Programming Languages\\UCLA-CS131-S18}
\author{Quentin Truong\\Taught by Professor Eggert}
\date{Spring 2018}


\begin{document}
\maketitle
\tableofcontents
\pagenumbering{arabic}
\clearpage


%========================================================
\section{Ch1: Programming Languages}
\subsection{Introduction}
	\begin{easylist}  
	\ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Practical Magic
        && Useful and beautiful
        & Programming Languages
        && ML, Java, Prolog
	\end{easylist}

\subsection{The Amazing Variety}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Imperative Languages (C)
        && Hallmarks: assignment and iteration
        & Functional Languages (ML, Lisp)
        && Hallmarks: recursion and single-valued variables
        && Factorial is natural to functional
        & Logic Programming Languages (Prolog)
        && Express program in terms of rules about logical inferences and proving things
        && Factorial is very not natural to logic programming; not well suited to mathematical functions
        & Object-oriented Programming Languages (Java)
        && Object is a bundle of data which knows how to do things to itself
        && Helps keep large programs organized
        & Other categories
        && Applicative, concurrent, constraint, declarative, definitional, procedural scripting, single-asstgnmen
        & Multi-paradigm
        && JavaScript, OCaml, Python, Ruby
        & Others
        && FORTH is stack-oriented
        && APL is a unique functional language relying on large character sets with many symbols that most users don't have
    \end{easylist}

\subsection{The Odd Controversies}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Partisans
        && For every language b/c some advantages
        && But all languages have advantages and disadvantages
        && Disagreement even on basic terminology, like object oriented
    \end{easylist}

\subsection{The Intriguing Evolution}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Programming languages change
        && All change; new ones evolve from old ones
        && Many have several dialects
        && Fortran is entirely only dialects (sequence of standards)
    \end{easylist}

\subsection{The Many Connections}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Styles
        && Object Oriented, like Java -> objects
        && Functional, like ML -> many small functions
        && Logic, like Prolog -> express problem as searches in logically defined space of solutions
        & Language evolution driven by hardware + applications
        && AI encouraged Lisp; Classes bc Simula
    \end{easylist}

\subsection{A Word about Application Programming Interfaces}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Application Programming Interfaces (API)
        && May implement data structures, GUI, network input/output, encryption, security, other services
        && Is much of language; more than the printed specification of the language
    \end{easylist}
\clearpage
%========================================================

%========================================================
\section{Ch2: Defining Program Syntax}
\subsection{Introduction}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Syntax
        && Language definition that says how programs look (form and structure)
        && Appearance, delimiters, etc
        & Semantics
        && language definition that says what programs do (behavior and meaning)
        && How it works, what can go wrong, etc
        & Formal grammar
        && Used to define programming language syntax
    \end{easylist}

\subsection{A Grammar Example for English}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & English
        && Article, noun, noun phrase, verb, sentence composes subset of unpunctuated English
        && Grammar used as set of rules that say how to build a parse tree (sentence at root)
        && Language defined by grammar is set of all strings that can be formed as fringes of parse trees
    \end{easylist}

\subsection{A Grammar Example for a Programming Language}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Infinite language have arbitrarily long expressions
        && Recursive grammar where exprsesions can be children of expressions
        &&& Expressions can be sum/product/enclosed/variable of two expressions
    \end{easylist}

\subsection{A Definition of Grammars: Backus-Naur Form}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Tokens
        && Smallest units of syntax
        && Strings and symbols not consisting of smaller parts (cat, if, !=)
        & Non-terminal symbols
        && Correspond to different language constructs (sentences, noun pharses, statements)
        && Special non terminal symbol \textless empty>
        & Productions
        && Possible way of building parse tree
        && LHS is non-terminal; RHS is sequence of one or more things
        & Start symbol
        && Special non-terminal symbol
        & \textless if-stmt \textgreater ::= if \textless expr \textgreater then \textless stmt \textgreater else-part \textgreater
        && \textless else-part \textgreater ::= else \textless stmt \textgreater | \textless empty \textgreater
    \end{easylist}

\subsection{Writing Grammars}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Divide and Conquer
        && \textless var-dec \textgreater ::= \textless type-name \textgreater \textless declarator-list \textgreater ;
        && \textless declarator-list \textgreater ::= \textless declarator \textgreater | \textless declarator \textgreater , \textless declarator-list \textgreater
        && BNF syntax defines programming language constructs
    \end{easylist}

\subsection{Lexical Structure and Phrase Structure}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Lexical Structure
        && How to divide program text into tokens
        & Phrase Structure
        && How to construct parse trees with tokens at leaves
        & Separate lexical and phrase structure
        && Otherwise, is ugly, hard to read, and complicated
        & Lexer
        && Reads input file and converts to stream of tokens, discarding white space and comments
        & Parser
        && Reads stream of tokens and forms parse tree
        & Free-format languages 
        && End-of-line is no more special than space or tab
        && Most modern languages don't care for column position, so could write program as a single line
        && Python is an exception
    \end{easylist}

\subsection{Other Grammar Forms}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Backus-Naur Form (BNF)
        && Has many minor variations, use = or -\textgreater instead of ::=
        && Metasymobls are part of language of the definition, not of the language being defined
        & Extended Backus-Naur Form (EBNF)
        && Might use brackets, parentheses, etc
        && [optional], \{repeatable\}, (group)
        && Use quotes to denote tokens as not metasymbols
        & Syntax Diagrams (Railroad diagram)
        && Way to express grammars graphically
        && Uses circles, rectangles, and arrows to show flow and possible control flows
        && Railroad diagram bc many many arrows
        && Good for casual use; hard for machines + parse trees
        & Formal, Context-free Grammars
        && Formal languages study formal grammars
        && Context-free b/c children of node in parse tree depend only on that node's non-terminal symbol (not on context of neighboring nodes in tree)
        && Regular grammars (less expressive, good for lexical structure) and context-sensitive grammars (more expressive, good for phrase structure) both exist
    \end{easylist}

\subsection{Conclusion}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Grammars
        && Used to define syntax (lexical and phrase structure)
        && Lexical is division of program text into meaningful tokens
        && Phrase is organization of tokens into parse tree for meaningful structures
        & Good grammars
        && If grammar is in the correct form, can be fed into parser-generator
        && Simple, readable, short grammars are more memorable + easier to learn/use
    \end{easylist}
\clearpage
%========================================================

%========================================================
\section{Ch3: Where Syntax Meets Semantics}
\subsection{Introduction}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Grammar
        && Set of rules for constructing parse trees
        && Language defined by grammar is set of fringes of parse trees
        & Equivalent Grammars
        && Different grammars may generate identical languages (bc identical fringes despite different internal structure)
        & Internal structure of parse tree
        && Semantics must be unambiguous
    \end{easylist}

\subsection{Operators}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Operator (+, *)
        && Refers to both the tokens for the operation, and the operation itself
        && Unary, binary, ternary take one, two, three operands
        & Operands
        && Inputs to operator
        & Infix Notation
        && Operator between operands
        && Postfix has operator after operands
    \end{easylist}

\subsection{Precedence}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Higher precedence performed before lower precedence
        && Use different non-terminal symbol for each precedence level
        && Non-terminal symbols in this chain are in order of precedence, from lowest to highest (is generalizable)
        & Precedence Levels
        && Smalltalk has 1 precedence level (no precedence)
        && C has 15, Pascal has 5
        && Can add unnecessary parentheses to make expressions more readable
    \end{easylist}

\subsection{Associativity}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Grammar for a language must generate only one parse tree for each expression
        && So need to implement left/right-associative (eliminate the other direction)
        && \textless exp \textgreater ::= \textless exp \textgreater + \textless exp \textgreater
        && \textless exp \textgreater ::= \textless exp \textgreater + \textless mulexp \textgreater $\vert$ \textless mulexp \textgreater
        && Only recursive on left side, so that it is left associative and grows tree left
        & Nonassociative operator
        && Has no defined behavior when used in sequence in expression 
        && Prolog 'a :-  b :- c' is just a syntax error; also '1 \textless 2 \textless 3'
    \end{easylist}

\subsection{Other Ambiguities}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Ambiguous Grammars
        && Allows construction of two different parse trees for same string
        & Dangling else
        && Optional else part, so grammar may be ambiguous
        && Can fix using \textless fullstmt \textgreater
        && Or use indenting (Python) or other ways to fix it
    \end{easylist}

\subsection{Cluttered Grammars}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Novice users
        && Just want to find out what legal programs look like
        & Advanced users and language-system implementers
        && Need exact, detailed definition
        & Automatic tools
        && Complete and unambiguous
        && Not sensitive to clutter
    \end{easylist}

\subsection{Parse Trees and EBNF}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & EBNF can be easier to read
        && Eliminates some confusing recursions, but obscures structure of parse tree
        && Must quote many tokens, bc they are tokens in the language being defined
        && Grammar still incomplete without explanation of intended associativity for binary operators
    \end{easylist}

\subsection{Abstract Syntax Trees}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Abstract Syntax Trees (AST)
        && Node for every operation, with subtree for every operand
        && Many language systems ust AST as internal representation of program
        && Type-checking and post-parsing carried out on AST
    \end{easylist}

\subsection{Conclusion}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Grammar defines more than syntax
        & Unique parse trees allow us to begin to define semantics
        & Parse trees and ASTs are where syntax meet semantics
    \end{easylist}
\clearpage
%========================================================

%========================================================
\section{Ch5: A First Look at ML}
\subsection{Introduction}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Standard ML is the popular functional language
        && Mostly learned just for knowledge of programming languages
    \end{easylist}

\subsection{Getting Started with an ML Language System}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & -1 + 2 * 3
        && val it = 7 : int
        && Very powerful type-inference system
        && 'it' is a variable whose value is the value of the last expression
    \end{easylist}

\subsection{Constants, Operators, Conditional Expressions, Type Conversion and Function Application, Variable Definition}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Constants
        && real if decimal, int if integer, negation operator is a tilde
        && ML is case sensitive
        & Operators
        && Integers: + - * div mod
        && Reals: + - * tilde /
        && String: \^ for concat
        && Inequality: \textgreater \textless
        & If-then-else 
        && if \textless expr \textgreater then \textless expr \textgreater else \textless expr \textgreater;
        & Type conversions
        && Never does conversions automatically
        & Parentheses around function parameters are unnecessary
        & Variable definition
        && val x = 1 + 2;
        && Letter followed by zero or more additional letters, digits, underscores
        && ML expects input to be a series of definitions, so if type just an expression, will set val it = exp
    \end{easylist}

\subsection{Garbage Collection, Tuples and Lists}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & GC \#0.0.0.0.1.3 (0 ms)
        && ML prints this if performing garbage collection (SML/NJ)
        & Tuples
        && Ordered collection of values of different types (tuples OK too)
        && val p1 = ("red", (300, 200)) 
        &&& val p1 = ("red", (300,200)) : string * (int * int)
        && * is type constructor
        && To extract ith element of tuple named v, write \#i v
        & List
        && Elements must be of same type
        && Uses square brackets
        && Empty list is nil or [] and has unknown type
        && @ symbol does concatenation for lists
        && cons (construct) is written as :: and wil glue elements onto front of list
        && head (hd) and tail (tl) will extact first/all except first parts of a list
        & Type variables
        && Type that is unknown
        && 'a list might be any type
        && x = [] is restricted to type, so use null x instead
        & Recursive Functions
        && Could use hd to take first element, and recursively call, resulting in iteration
    \end{easylist}

\subsection{Function Definitions}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Polymorphic function
        && Paramters allow different types
        && Ex: List length function
    \end{easylist}

\subsection{ML Types and Type Annotations}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Types: int, real, bool, char, string
        & Constructors: * for tuples, list for lists, -> for function types
        & Type annotations: necessary for ambiguous situations
        && fun prod(a:real, b:real) : real = a * b;
        && Many larger ML projects use type annotations heavily
    \end{easylist}

\clearpage
%========================================================

%========================================================
\section{Ch7: A Second Look at ML}
\subsection{Patterns}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & A variable is a pattern that matches anything and bnids to it
        & Underscore character matches anything and does not introduce new variables
        & Constant is pattern that matches only that constant value
        & Tuple of patterns is pattern that matches tuple of any right size, whose contents match subpatterns
        & List of patterns is pattern that matches list of rgiht size, whose contents match subpatterns
        & Cons of patterns is pattern that matches non-empty list whose head and tail match the subpatterns
        && x :: xs matches any non-empty list; binds x to head; binds xs to tail
    \end{easylist}

\subsection{Using Multiple Patterns for Functions}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & fun f 0 = "zero" $|$ f 1 = "one";
        && Two different function bodies (still nonexhaustive)
        && If overlapping, tries patterns in order they are listed, using the first one that matches
    \end{easylist}

\subsection{Pattern-Matching Style}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & If-else
        && Equivalent to the multiple patterns
        && Multiple patterns is often preferred and cleaner
        & Functions
        && null l returns true if the list l is empty
        && length l returns the number of elements in the list l
        && hd l returns the first element of l
        && tl l returns all but the first element of l
        & Variable name cannot be used more than once unless you want them to be legal
        & Patterns can be used in definitions
        && val (a, b) = (1, 2.3);
        &&& val a = 1 : int
        &&& val b = 2.3 : real
        && val a :: b = [1, 2, 3, 4, 5];
        &&& val a = 1 : int
        &&& val b = [2, 3, 4, 5] : int list
    \end{easylist}

\subsection{Local Variable Definitions and Nested Function Definitions}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & \textless let-exp \textgreater ::= let \textless definitions \textgreater in \textless expression \textgreater end
        && \textless definitions \textgreater hold only within \textless let-exp \textgreater
        & Generally don't need to use \# to extract from tuple, can use pattern matching
        & Use halve function to divide list into pair of half-lists
        && half [1]
        &&& val it = ([1], []) : int list * int list
        & Use merge function to merge
        & Local functions
        && Can define functions inside other function definitions
    \end{easylist}
\clearpage
%========================================================

%========================================================
\section{Ch9: A Third Look at ML}
\subsection{Introduction}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Case expressions
        && Pattern matching can be used in many other places, including case expressions
        & Higher order functions
        && Take other functions as parameters or produces them as returned values
        && Used more often in functional languages than in imperative languages
    \end{easylist}

\subsection{More Pattern Matching}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Rule
        && \textless rule \textgreater ::= \textless pattern \textgreater = \textgreater \textless expression \textgreater
        & Match
        && \textless match \textgreater ::= \textless rule \textgreater $|$ \textless rule \textgreater '$|$' \textless match \textgreater
        & Case
        && \textless case-exp \textgreater ::= case \textless expression \textgreater of \textless match \textgreater
    \end{easylist}

\subsection{Function Values and Anonymous Functions}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Predefined functions like ord and -:
        && Variables just like others, but initially bound to functions
        & New functions and bind name to function automatically
        && fun f x = x + 2
        & Anonymous function
        && fn x =\textgreater x + 2
        && Useful when need small function in one place and don't want to clutter
        & op \textless
        && Extracts the function used by the operator \textless
    \end{easylist}

\subsection{Higher-Order Functions and Currying}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Order
        && Function that does not take any functions as parameters and does not return a function value has order 1
        && Function that takes a function as a parameter or returns a function value has order n + 1, where n is the order of its highest-order parameter or returned value
        && Higher-order function is an nth order function where n is greater than 1
        & Currying
        && Use higher order functions to pass multiple parameters into a function
        && Function takes first parameter and returns another function, which takes second parameter and returns final result
        && Is an alternative way to passing multiple parameters (could pass tuple)
        && Main advantages is that we can pass only some of the parameters, and save the function
        && fun g a b c is equivalent to fun g a =\textgreater fn b =\textgreater fn c
    \end{easylist}

\subsection{Predefined Higher Order Functions}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & map
        && Applies some function to every element in the list
        & foldr
        && Combines all elements into one value with starting value
        && foldr (op * ) 1 [1, 2, 3, 4];
        &&& val it = 24 : int
        && foldr (op ::) [5] [1, 2, 3, 4];
        &&& val it = [1, 2, 3, 4, 5] : int list
        && foldr (op \string^) "" ["abc", "def", "ghi"]
        &&& val it = "abcdefghi" : string
        & foldl
        && same as foldr, except proceeds from left to right
    \end{easylist}
\clearpage
%========================================================

%========================================================
\section{Ch4: Langauge Systems}
\subsection{The Classical Sequence}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Language System
        && Is what makes programming languages actually work
        & Integrated Development Environment
        && Single interface for editing, running, and debugging programs
        & Classical Sequence of Language-System steps
        && Editor creates source file
        && Compiler creates assembly-language file
        &&& Translates program from original high-level lnaguage into assembly langauge (instructions for processor)
        && Assembler creates object file
        &&& Converts each instruction into machine language
        && Linker creates executable file
        &&& Collect and combine different parts of program
        && Loader creates a running program in memory
    \end{easylist}

\subsection{Optimization}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Compiler automatically optimizes code to make it faster and/or take up less memory
        & Loop invariant removal
        && Moves calculations of values which don't change outside the loop
        & Code may be oreoranized, removed, or added
        && Not obvious what assembly code will be generated
    \end{easylist}

\subsection{Variations on the Classical Sequence}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Hiding steps
        && gcc will compile, assemble, and link
        && Using gcc, as, and ld can recreate these steps
        & Integrated Development Environment
        && Integrated editor will supply indenting and colors to make it easier to read
        && May also provide source-control features to track verisons and coordinate collaboration
        && May help with rebuilding automatically, especially when only a few files have changes
        & Interpreters
        && Executes program without translating it beforehand
        & Virtual Machines
        && Perform classical sequence of language-system steps to get an executable for a virtual machine
        && Virtual-machine simulator is an interpreter, and compiles high-level program into intermediate code
        && Virtual machines are often platform independent and more secure (b/c is never in control of physical processor)
        && Java virtual machine is intermediate code supported on many different physical machines
        && Wide spectrum of intermediate languages, ranging from pure interpreter to compiler
        & Delayed Linking
        && Windows' load-time dynamic linking links program to all library functions just before program begins running (.dll)
        && Windows' run-time dynamic linking require explicit calls to find and load functions from library (.dll)
        && Unix shared libraries are linked by loader just before program begins running (.so)
        && Unix dynamically loaded libraries require explicit calls to fnid and load functions during runtime (.so)
        && Multiple programs can share library function (fewer copies)
        && Library function may be updated independently of the program
        && Only load what is necessary, so startup is faster
        & Profiling
        && Instead of guessing what part of code is most important, compile twice
        && Compile program, run it and collect statistics, then recompile and generate better code
        & Dynamic Compilation
        && Just-in-time compilation
        && Compile after program starts running, once the function is actually called
        && Java virtual machine uses this
    \end{easylist}

\subsection{Binding Times}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Language-Definition Time
        && Keywords are part of language definition and language-system implementations must conform
        & Language-Implementation Time
        && Properties left out of language definition
        && Range for int is implementation dependent in C and ML
        && May introduce limits, such as on maximum length of name, levels of nesting, etc
        & Compile Time
        && Type of variable is bound
        && Bind variable definitons to reference; nontrivial for large programs
        & Link Time
        && Find definitons of library functions to match each reference
        & Load Time
        && May adjust program, then load into memory
        & Runtime
        && Early binding is when property is bound before runtime
        &&& More secure, less things go wrong
        && Late binding is runtime binding
        &&& More runtime flexibility
        && Each high-level language has different binding-time implications
        &&& In lisp, may not know type until runtime
    \end{easylist}

\subsection{Debuggers}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Core dump
        && When langauge system hits fatal defect, writes copy of memory to a file
        && Useful for postmortem analysis
        && Language-system tool later extracts meaningful information from dump file, such as traceback, value of variables, etc
        & Interactive debuggers allow programmer to inspect and modify variables while still running
        && Debugger must express things in terms of the original program, not the compiled changes
        && Must know the names of variables/functions, not just memory addresses
        && But the optimizations of modern compilers weaken the connection between source and machine code, meaning that debuggers must conceal the actions of compilers and give the programmer the impression of debugging directly
        & Integrated language system can provide editing and recompiling program while still running
    \end{easylist}

\subsection{Runtime Support}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Runtime support
        && Additonal code included even though program does not explicitly refer to it, used in the following:
        && Startup processing, to set up processor and memory in thew ay high-level code expects
        && Exception handling, finding the exception handler or catching exceptions
        && Memory management, icluding allocation and freeing
        && Operating system input communication
        && Concurrrent execution
    \end{easylist}

\subsection{Introduction}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Classical Sequence
        && Edit, compile, assemble, link, load, run
        & Binding times
        && Language definition, language implementation
        && Early, late
        & Debuggers and runtime support
        & Programming language is not the same as programming-language system
    \end{easylist}
\clearpage
%========================================================

%========================================================
\section{Ch6: Types}
\subsection{Menagerie of Types}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & A Type is a Set
        && Can only have values from a certain set
        && Share common representation in how they are encoded in memory
        && Supports particular operations
        & Primitive Types and Constructed Types
        && Primitive types are like int and real
        && Constructed types are defined by programmer
        && Definition of progarmming language may say exactly what set each primitive type must be, or may leave room for choosing different sets
        &&& Java wants programs to have same result across platforms, so defines all types completely
        &&& C and ML allow different implementations
        & Enumerations
        && Define new types by ilsting all elements of the type
        && Enums in C just wraps integers, allowing you to add elements as if integers
        && ML completely hides the implementation
        & Tuples
        && Generalized to n-tuples of any type
        && Aggregate types are tuples, records, arrays, strings, lists
        && Scalar types are primitives and enumerations
        & Arrays, Strings, Lists
        && Set A$^n$ is set of all vectors of length n 
        && Array indices are not always only integers (Pascal)
        & Unions
        && Mutiple elements in same block of memory
        && Discriminated Union supports records which also contain enumeration
        & Subtypes
        && Subset of an existing set
        && Can support superset of operations
        & Function Types
        && From set A to set B
    \end{easylist}

\subsection{Uses for Types}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Type Annotations
        && Explicit type information used to determine type/documentation
        && Required in Java; allowed in ML; disallowed in Prolog, but comments serve the purpose
        && ANSI Basic has ultra-compact type annotation inside the variable name
        & Type Inference
        && Most languages infer types based on operands or value
        && ML infers types for every expression
        & Type Checking
        && Point is to prevent incorrect operations to operands
        && Static type checking determines type for everything before running
        &&& Generates consistent picture of types
        && Dynamic type checking checks types at runtime
        &&& Helpful for operators, etc
        && Many systems implement both static and dynamic bc hard to know exact type + is expensive to check all types
        && Strongly typed languages have type checking thorough enough to prevent any mistakes
        && Java is strongly typed, Pascal is somewhat weak, C is more weak
        & Type-Equivalence Issues
        && Name-equivalence is when types are equivalent iff same name
        && Structural equivalence is when types are equivalent iff constructed from same primitive types using same constructors in same order
    \end{easylist}

\subsection{Conclusion}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & Types are similar to mathematical sets
        & Abstract type describes types defined only in terms of supported operations
        & Static vs dynamic type checking
        & Name vs structural equivalence
        & Type annotation vs inference
    \end{easylist}
\clearpage
%========================================================

%========================================================
\section{Ch4: Langauge Systems}
\subsection{Introduction}
    \begin{easylist}  
    \ListProperties(Hide=100, Hang=true, Progressive=4ex, Style*=--\ , Style2*=$\bullet\ $)
        & 
    \end{easylist}
\clearpage
%========================================================

\end{document}